{
	"meta": {
		"generatedAt": "2025-08-11T03:45:22.025Z",
		"tasksAnalyzed": 15,
		"totalTasks": 15,
		"analysisCount": 15,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 1,
			"taskTitle": "Bootstrap Rust workspace, CI, and coverage gating",
			"complexityScore": 5,
			"recommendedSubtasks": 8,
			"expansionPrompt": "Break this bootstrap into 8 subtasks: (1) Create cargo workspace with crates renamify-core (lib) and renamify-cli (bin); add rust-toolchain.toml pinned to stable 1.80.x. (2) Add dependencies/dev-deps with versions; allow unused in initial commit. (3) Configure rustfmt.toml (2024+ style) and clippy settings (deny warnings; enable pedantic/nursery where practical). (4) Add minimal lib/cli skeletons and a trivial unit test in core. (5) Integrate cargo-llvm-cov with config to collect coverage only for renamify-core, set 100% threshold. (6) GitHub Actions workflow: 3-OS matrix, rust-cache, toolchain install, fmt --check, clippy -D warnings, tests, llvm-cov, upload HTML artifact on PRs. (7) Add repository hygiene: .gitignore (including /.renamify/), LICENSE placeholders, CONTRIBUTING notes for CI/coverage. (8) Verify locally and document make-like scripts or cargo aliases for lint, test, cov. Define acceptance criteria mirroring the test strategy and ensure workflows fail below coverage threshold.",
			"reasoning": "Scope is setup-heavy but straightforward; main risks are cross-OS CI idiosyncrasies and reliable llvm-cov setup with strict 100% gating."
		},
		{
			"taskId": 2,
			"taskTitle": "Case token model and cross-style converters",
			"complexityScore": 7,
			"recommendedSubtasks": 10,
			"expansionPrompt": "Decompose into: (1) Define public API: Style, Token, TokenModel. (2) Implement ASCII-aware tokenization using bstr with camel/digit boundary heuristics and acronym handling per spec. (3) Implement detect_style with robust separators/case checks. (4) Implement to_style for all styles with casing rules and Title/Train behavior. (5) Implement acronym casing heuristics (<=2 all-caps preserved in Camel/Pascal; otherwise Pascal-ish). (6) Implement generate_variant_map with deterministic ordering (BTreeMap) and stable alternation order. (7) Add serialize/debug helpers. (8) Property tests with proptest for normalization invariants. (9) Golden/round-trip tests including edge cases (digits, acronyms, single-word, non-ASCII rejection). (10) Achieve 100% module coverage and document limitations.",
			"reasoning": "Non-trivial parsing and casing rules plus property testing increase complexity; determinism and edge-case handling are key for downstream correctness."
		},
		{
			"taskId": 3,
			"taskTitle": "Regex generation and boundary heuristics",
			"complexityScore": 7,
			"recommendedSubtasks": 9,
			"expansionPrompt": "Plan: (1) Design boundary model without \\b; implement is_alnum and is_boundary over bytes. (2) Escape and build single alternation pattern using regex::bytes::Regex with (?u) avoided; ensure compile-time correctness. (3) Map matches back to variants (capture groups or find+slice compare), evaluating simplicity vs performance. (4) Implement MatchPattern with constructor build_pattern and variant mapping. (5) Add post-filter to enforce boundaries on found spans. (6) Unit tests for boundaries across styles, ensuring no superstring matches. (7) Snapshot tests for pattern rendering/invariants. (8) Fuzz harness (cargo-fuzz) for variant sets to avoid panics/catastrophic behavior. (9) Criterion microbenchmarks for compile and search time; document thresholds.",
			"reasoning": "Building safe, performant alternations with custom boundaries and fuzz safety is moderately complex; careful post-filtering avoids false positives."
		},
		{
			"taskId": 4,
			"taskTitle": "Repo scan and streaming plan.json generator",
			"complexityScore": 8,
			"recommendedSubtasks": 12,
			"expansionPrompt": "Outline 12 subtasks: (1) Define PlanOptions, MatchHunk, Plan schemas (serde). (2) ignore::WalkBuilder setup honoring .gitignore and includes/excludes via globset. (3) Parallel scanning with build_parallel and rayon tuning. (4) Binary detection via content_inspector with override. (5) File IO strategy: memmap2 when feasible else buffered read; handle large files. (6) Integrate MatchPattern from Task 3 to find matches and compute before/after per hunk. (7) Minimal context computation and line/col calculation. (8) Streaming JSON writer via serde_json::Serializer to avoid high memory; write header, stream matches/renames arrays, footer. (9) Stats aggregation per variant and file. (10) Stable plan id generation (ULID or SHA256 of inputs+timestamp) and default path under .renamify/plan.json. (11) Performance tuning and backpressure; document buffer sizes. (12) Integration tests including performance envelope, .gitignore behavior, and binary/include/exclude edge cases.",
			"reasoning": "High I/O throughput, parallelism, and streaming serialization make this performance-critical and correctness-sensitive across diverse repos."
		},
		{
			"taskId": 5,
			"taskTitle": "File and directory rename planning with depth ordering and collision detection",
			"complexityScore": 7,
			"recommendedSubtasks": 8,
			"expansionPrompt": "Break down: (1) Implement tree walk (ignore::Walk) collecting candidate paths. (2) Generate rename candidates by applying mapping to file/dir names (not full path) with possibly multiple variants. (3) Sort: directories by depth desc, then files; ensure deterministic ordering. (4) Collision detection: map from->to; detect duplicates and record conflicts in plan. (5) Case-insensitive filesystem handling flag (probe or injected) and staged rename requirement. (6) Windows reserved names/invalid chars guard and failure signaling. (7) Symlink policy: skip or note symlink entries per safety policy. (8) Unit/integration tests covering sort, collisions, case-only changes, and symlinks.",
			"reasoning": "Core difficulty is deterministic planning with collisions and cross-platform path edge cases, especially case-insensitivity and Windows quirks."
		},
		{
			"taskId": 6,
			"taskTitle": "Terminal preview: table and unified diff formatting",
			"complexityScore": 6,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Plan: (1) Implement table view with comfy-table and nu-ansi-term, columns and totals per spec; ANSI-off mode for non-TTY. (2) Implement diff view using similar unified_diff for content hunks; group and badge renames. (3) JSON preview mode: emit path or stream plan JSON to stdout. (4) CLI plumbing to select preview format and normalize path separators for snapshots. (5) Snapshot fixtures (insta) for table and diff on small repo. (6) Verify counts vs stats in plan.json. (7) Cross-platform normalization and golden tests without ANSI in CI.",
			"reasoning": "Formatting and cross-platform output normalization are moderate; relies on existing crates but needs careful snapshot stability."
		},
		{
			"taskId": 7,
			"taskTitle": "CLI command layer and argument parsing",
			"complexityScore": 6,
			"recommendedSubtasks": 8,
			"expansionPrompt": "Create: (1) Clap derive-based command/args with ArgEnums for styles and preview formats, list parsing, and defaults. (2) Wire commands: plan/apply/undo/redo/status/history/dry-run to core APIs. (3) Exit code mapping (0/1/2/3) with anyhow error contexts. (4) SIGINT handling: cancel long operations and clean partial plan files. (5) Shell completion generation (clap complete) and packaging. (6) NO_COLOR and TTY detection for output. (7) Integration tests with assert_cmd/assert_fs for flags, help text, and exit codes. (8) Error messages UX consistency and logging hooks.",
			"reasoning": "Multi-command UX, robust parsing, and signal handling add moderate complexity; most logic delegates to core modules."
		},
		{
			"taskId": 8,
			"taskTitle": "Atomic apply engine with rollback and staged renames",
			"complexityScore": 9,
			"recommendedSubtasks": 13,
			"expansionPrompt": "Decompose into: (1) Execution plan builder from plan.json (working set of edits/renames). (2) Backup manager writing to .renamify/backups/<id>/ with perms preserved; hard-link optimization where safe. (3) Content edit apply: temp file write, fsync file and parent dir (POSIX), Windows-safe replace behavior. (4) Depth-first rename executor; case-only rename two-step on case-insensitive FS. (5) Cross-device move detector and copy+remove fallback preserving metadata. (6) Journal for rollback steps to guarantee restoration on failure. (7) Rollback implementation for edits and renames with idempotence. (8) Symlink handling per policy (skip edit targets, rename symlink path if allowed). (9) Apply logging to .renamify/apply.log. (10) Optional git commit integration via porcelain commands. (11) Error taxonomy and surface with actionable messages. (12) E2E tests inducing failures to verify zero partial state. (13) Performance considerations and contention handling on Windows (sharing violations).",
			"reasoning": "High-risk, cross-platform file mutation with durability and rollback guarantees; many edge cases (case-only, cross-device, locks) drive complexity."
		},
		{
			"taskId": 9,
			"taskTitle": "Apply-time conflict detection and limited auto-resolution",
			"complexityScore": 7,
			"recommendedSubtasks": 9,
			"expansionPrompt": "Steps: (1) Define hunk re-validation logic with small positional tolerance and whitespace normalization. (2) Implement already-applied detection (new_variant present) to auto-resolve. (3) Window expansion around hunks and efficient rescans. (4) Conflict collection and serialization to .renamify/conflicts/<id>.json. (5) Integration with apply engine: stop on conflicts unless --force-with-conflicts. (6) Exit code 1 behavior and messaging. (7) Tests covering whitespace-only changes, shifted columns, and removed tokens. (8) Config toggles for tolerance/whitespace policy. (9) Documentation of conflict semantics and operator guidance.",
			"reasoning": "Requires careful, fast revalidation and nuanced auto-resolution without full 3-way merge; correctness and UX are the primary challenges."
		},
		{
			"taskId": 10,
			"taskTitle": "History store, undo/redo, and status commands",
			"complexityScore": 7,
			"recommendedSubtasks": 9,
			"expansionPrompt": "Plan: (1) Define history entry schema and serde for .renamify/history.json (append-only). (2) Compute and store file checksums (SHA-256) and metadata after apply. (3) Implement writer with atomic update and simple file lock to avoid corruption. (4) Undo: restore from backups, reverse renames (with staged logic), and append revert_of entry. (5) Redo: re-apply using stored plan/metadata; append linking entry. (6) Status: summarize last id, pending conflicts, and cleanliness from our records. (7) CLI integration for undo/redo/status/history list with JSON or pretty table. (8) Robust corruption detection and clear errors. (9) Tests for serialization, undo/redo byte-for-byte restoration, and corruption handling.",
			"reasoning": "State management with integrity and reversible operations adds non-trivial logic; must coordinate with apply engine and handle corruption safely."
		},
		{
			"taskId": 11,
			"taskTitle": "Cross-platform filesystem safety and symlink handling",
			"complexityScore": 8,
			"recommendedSubtasks": 10,
			"expansionPrompt": "Outline: (1) Case sensitivity probe and caching; injectable for tests. (2) Windows long-path handling (\\\\?\\ prefix where needed) and canonicalization strategy. (3) Reserved names/invalid char filters and error surfacing. (4) Symlink policy enforcement: do not traverse outside root; skip editing targets; allow renaming links themselves. (5) Same-file and path traversal protections via canonical paths. (6) Retry with exponential backoff on Windows sharing violations. (7) Cross-platform permission handling and metadata preservation. (8) Integration points in plan/apply/rename logic. (9) Platform-specific tests and CI matrix coverage. (10) Documentation of safety model and limitations.",
			"reasoning": "Platform quirks (Windows paths, case-insensitivity, symlinks, locks) introduce many edge cases; correctness and safety are paramount."
		},
		{
			"taskId": 12,
			"taskTitle": "Performance, streaming, fuzzing, and property testing hardening",
			"complexityScore": 7,
			"recommendedSubtasks": 8,
			"expansionPrompt": "Plan: (1) Tune WalkBuilder parallelism and thread pools based on num_cpus. (2) Ensure plan.json streaming keeps memory bounded; document buffer sizes and backpressure behavior. (3) Adopt memmap2 responsibly with fallbacks; measure impact. (4) Criterion benchmarks for scan, regex build/search, and end-to-end planning; add benches/. (5) Proptest suites for tokenization and boundary invariants. (6) cargo-fuzz harnesses for regex generation and boundary checking; schedule nightly CI with time budget. (7) Perf integration test gated by PERF=1; record baseline targets (<1.5x ripgrep). (8) Document tuning knobs and profiling guidance.",
			"reasoning": "Focuses on systematic performance and safety validation across modules; requires tooling, CI scheduling, and disciplined measurement."
		},
		{
			"taskId": 13,
			"taskTitle": "VS Code extension (TypeScript) integrating with CLI",
			"complexityScore": 7,
			"recommendedSubtasks": 11,
			"expansionPrompt": "Decompose: (1) Scaffold extension (Node 20/TS 5.5), ESLint/Prettier, bundler (tsup/esbuild). (2) Commands: Plan, Preview, Apply, Undo with contributions in package.json. (3) Workspace-scoped settings (renamify.cliPath etc.). (4) Process management via child_process.spawn with AbortController cancellation; stream stdout/stderr. (5) JSON parsing and error mapping from CLI exit codes. (6) Preview webview using diff2html, lazy loading, and style filters. (7) Persist last inputs per-workspace. (8) CLI binary discovery/download flow with caching under extension storage. (9) Progress UI and cancellation UX. (10) Tests with @vscode/test-electron and mocked child process. (11) VSIX packaging, CI build, and smoke tests.",
			"reasoning": "Typical VS Code extension complexity with process orchestration, webview rendering, and cross-platform packaging; depends on CLI stability."
		},
		{
			"taskId": 14,
			"taskTitle": "MCP server wrapper (Node/TypeScript)",
			"complexityScore": 6,
			"recommendedSubtasks": 8,
			"expansionPrompt": "Plan: (1) Define zod schemas for plan/history JSON. (2) Implement execa-based CLI wrapper with stdout/stderr capture and AbortSignal cancellation. (3) Map tools: plan/apply/undo/history/preview to CLI args and parse outputs. (4) Error normalization: map exit codes (0/1/2/3) to structured errors. (5) CLI path resolution and environment handling. (6) Package as @renamify/mcp with bin entry, tsup build, and npm publish config. (7) Unit tests for schema validation and arg mapping; integration tests in a temp git repo. (8) CI workflow and minimal usage docs.",
			"reasoning": "Straightforward process wrapper with schema validation and cancellation; main risks are robust error mapping and cross-platform child process behavior."
		},
		{
			"taskId": 15,
			"taskTitle": "Release packaging, installers, and documentation",
			"complexityScore": 8,
			"recommendedSubtasks": 12,
			"expansionPrompt": "Break into: (1) Cross-platform CI release workflow building Rust binaries for macOS (x64/arm64), Linux (x64/arm64/MUSL), Windows (x64), with checksums. (2) Optional zig/cross integration for MUSL/static where needed. (3) Archive naming/versioning and SBOM/checksum artifacts. (4) Homebrew tap formula automation. (5) Scoop manifest and validation; consider winget later. (6) curl | sh installer script resolving OS/arch and install path. (7) cargo publish for renamify-cli; document features and minimal deps. (8) README with quickstart, examples, safety/perf notes. (9) CONTRIBUTING, CHANGELOG (Keep a Changelog), and CLAUDE.md. (10) Examples/ folder with reproducible scenarios. (11) Link checks and doc CI; copy-paste command tests. (12) Release dry-run workflow and fresh-machine installer tests.",
			"reasoning": "Multi-target build/release automation plus installer scripts and comprehensive docs introduce coordination complexity and cross-platform nuances."
		}
	]
}